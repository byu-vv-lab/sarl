

Think about how to do quick dispatch to right routine for
numeric operation.

Add Herbrand arithmetic.

Add new type: HerbrandReal
  is numeric
  
Add new numeric factory: HerbrandFactory extends NumericFactory
Add HerbrandExpression extends NumericExpression

The arguments to a HerbranExpression can be any kinds of expression
(not just Herbrand).  So no cast is necessary.

Relational expressions can also include Herbrand and so cannot
be simplified.  Must have HerbrandRelational expressions?

In Universe:
  add(x,y)
: if at least one argument is Herbrand, use the HerbrandFactory.
Else use the numericFactory.

How to simplify in presence of mixed:

How to prove things in presence of mixed:
  translate Herbrand operations (+, -, ...) as uninterpreted functions
  PLUS, MINUS, ..., on real values?

How to substitute:
  same as always?
  
Create HerbrandFactory implements NumericFactory
  all operations result in a HerbrandExpression

Create HerbrandIdealFactory implement NumericFactory
  look at type: if at least one argument is Herbrand,
  result is Herbrand.
  add casts?
  
Real, HerbrandRealType, Integer, FiniteInteger...

Types:
  REAL, HERBRAND_REAL, INTEGER, HERBRAND_INTEGER
methods:
  isReal(): true iff REAL, HERBRAND_REAL
  isHerbrand(): true iff HERBRAND_REAL, HERBRAND_INTEGER

Better Idea:

How about creating a SymbolicRealType
and then within that a RealKind: IDEAL, HERBRAND, FLOAT

Similarly a SymbolicIntegerType:
IDEAL, HERBRAND, FINITE (cyclic, ...)

Create factories for these things.

Then create a HybridFactory that will look at the types of the arguments
in detail and choose which factory to delegate the operation too.

Universe:

SymbolicRealType herbrandRealType();
SymbolicRealType floatingPointType(int ..., int ...);
SymbolicIntegerType hergrandIntegerType();
SymbolicIntegerType finiteIntegerType(NumericExpression min, NumericExpression max, boolean cyclic);

